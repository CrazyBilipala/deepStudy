#第一章 对象导论
## 抽象过程
> + 万物皆对象
> + 程序设计中，抽象解决的是功能设计问题，能否使用更高效，利用率更高的代码来实现业务的问题
## 每个对象都有接口
> + 对象不是简单的数据类型，而是符合业务的数据类型
> + 规定对象的行为（设计模式中考虑），做到针对接口编程
## 每个对象都提供服务
> + 把对象想成“服务提供者”
## 被隐藏的具体实现
> + 对象的封装带来了巨大的好处
## 服用具体的实现
> + 灵活运用组合和关联（组合：汽车拥有引擎）
## 继承
> + 是导出类同基类产生区别的方法:1、写新的方法2、覆盖（overriding）方法
> + 对导出类方法来说，是否增加新的方法需要谨慎，如果保持不加，则基础类和导出类是纯粹替代的关系
## 伴随多态的可互换对象
> + Java默认后期绑定，这意味着直到运行期才知道实际处理的对象是什么，因此实现了多态
> + 向上转型
## 单根继承
> + Java是单继承，设计上更加简单，也方便GC
## 容器
> + ArrayList LinkedList等集合的数据结构
## 参数化类型
> + 向下转型是不安全的
> + 泛型确立了该容器存储的数据类型，这位以后调用数据时加快其解析过程
## 对象的创建和生命周期
> + Java的垃圾回收机制（GC）
## 异常处理：处理错误
## 并发编程
## Java与Internet
> + JavaWeb、服务器编程、数据库连接等，Java具有优势
> + 其他后端语言 node.js python php 可能是更好地选择

# 第二章 一切都是对象
## 用引用操纵对象
> + 引用（遥控） 对象（电视机）
## 必须由自己创建对象
> + new 
> + 存储的位置 1寄存器（无法人为控制，感觉不到寄存器存在的轨迹）2堆栈（对象引用）3堆（对象）4常量存储5非ROM存储（流对象、持久化对象）
> + 基本数据类型 boolean(1)btye(1)short(2)int(4)long(8)float(4)double(8)char(4)
> + 大数字操作类 BigInteger BigDecimal
> + Java的数组肯定会被初始化，要不然以null出现就会出错，这里比C系语言相比，因为他们不能保证数据先被初始化，将出现很多奇怪的问题，Java具有更大的安全性
## 永远不需要销毁对象
> + GC
## 创建新的数据类型：类
> + ThinkInJava com.jiangchao.l02 FirstCode.java

# 第三章 操作符
# 第四章 控制执行流程

# 第五章 初始化与清理
## 使用构造器初始化对象
## 方法重载
> + 方法名相同，形式参数不同的函数
> + 区分重载的方法：参数列表不同，包括类型的不同，和顺序的不同
> + 不可以通过返回值的类型来区分重载
## 默认构造函数
## this关键字
> + 构造函数中比较容易用到this
> + static
## 清理：终结处理和垃圾回收
> +对象可能不被垃圾回收
> + 垃圾回收并不等于“析构”
> + 垃圾回收只和内存相关 finalize() 是用来java调用native方法时，必须要清理对象（C或Cpp的对象）时才会用到
## 成员初始化
> + 指定初始化
## 构造器初始化
# 第六章 访问控制权限
## 包：库单元
> + package import 包名的命名方式
## Java访问权限修饰词
> + public protected private
## 接口和实现
## 类的访问权限
# 复用类
## 组合语法
> + 就是大类里夹带小的类
## 继承语法
## 代理
> + 用组合的方式把小类集成到大类里，然后完全暴露出小类的方法
## 向上转型
# 多态
> + 后期绑定
> + 构造函数是从最顶级的基础类开始按顺序执行
#  接口
> + 适配器模式  策略模式 工厂模式
# 内部类
> + 内部类可以获得外部类所有的成员变量，包括private
## 使用.this或者.new 
# 持有对象
## javase5以后的泛型
## List
+ > ArrayList 擅长随机访问，插入和删除较慢
+ > LinkedList 擅长插入和删除，随机访问较慢
## 迭代器 Iterator 